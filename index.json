[{"categories":["python","opentelemetry","apm"],"contents":" Introdu√ß√£o Todo desenvolvedor em algum momento de sua carreira j√° passou raiva com mudan√ßa de alguma tecnologia. Sempre que isso acontece, √© necess√°rio fazer uma s√©rie de modifica√ß√µes em um, ou v√°rios, sistemas que tomamos conta e √© exatamente isso que torna todo o processo de mudan√ßa doloroso. Atualmente, a empresa que estou trabalhando, decidiu por mudar a ferramenta de APM que utilizamos para centralizar o trace de todos os sistemas em um lugar s√≥. O problema que essa decis√£o gera √© a mudan√ßa de todos os pontos do c√≥digo que cont√©m a gera√ß√£o de trace utilizando a biblioteca de uma ferramenta para utilizar a biblioteca de outra ferramenta, ou seja, sempre que houver esse tipo de mudan√ßa todo esse trabalho precisar√° ser refeito.\nMas qual √© o problema de verdade? ü§î N√≥s, programadores, somos contratados para resolver problemas, por√©m, sempre que precisamos fazer algum tipo de \u0026ldquo;trabalho bra√ßal\u0026rdquo;, ou seja, ficar realizando alguma tarefa repetitiva, nos sentimos angustiados e desmotivados, e √© exatamente esse tipo de trabalho que √© gerado quando realizamos altera√ß√µes de ferramentas em algum n√≠vel.\nE n√£o tem nada que possamos fazer nessa situa√ß√£o a n√£o ser fazer esse trabalho chato? ü•π Ainda bem que a maioria dos desenvolvedores pensam igual, e com isso, criaram uma ferramenta gen√©rica capaz de centralizar a cria√ß√£o e envio de m√©tricas, traces e logs, assim, podendo ser enviado para v√°rios backends diferentes bastando mudar algumas configura√ß√µes. Essa ferramenta \u0026ldquo;milagrosa\u0026rdquo; que ser√° abordada nesse post √© o OpenTelemetry.\nüö® Observa√ß√£o importante: Como nem tudo s√£o flores, o trabalho chato precisar√° ser feito pelo menos uma vez, mudando da biblioteca atual para o OpenTelemetry.\nExplorando a Solu√ß√£o Aplica√ß√£o de Exemplo Para mostrar como tudo funciona, vamos utilizar uma API simples desenvolvida utilizando o framework web FastAPI:\n1 pip install fastapi uvicorn app.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from random import randint from typing import Optional import logging from fastapi import FastAPI logging.basicConfig(level=logging.INFO) app = FastAPI() logger = logging.getLogger(__name__) def roll(): return randint(1, 6) @app.get(\u0026#34;/rolldice\u0026#34;) async def roll_dice(player: Optional[str] = \u0026#34;Anonymous\u0026#34;): # Joga o dado e recebe o resultado aleat√≥rio result = roll() logger.warn(\u0026#34;%s is rolling the dice: %d\u0026#34;, player, result) return {\u0026#34;result\u0026#34;: result} Para testar a aplica√ß√£o, basta executar:\n1 2 3 4 5 6 7 # inicia a aplica√ß√£o uvicorn app:app --port 8080 # realiza uma requisi√ß√£o usando o player \u0026#34;An√¥nimo\u0026#34; curl -s http://localhost:8080/rolldice # realiza uma requisi√ß√£o usando o player \u0026#34;Lukerops\u0026#34; curl -s http://localhost:8080/rolldice?player=Lukerops Instrumentando o OpenTelemetry Existem duas formas de se instrumentar o OpenTelemetry no python, mas vou focar apenas na instrumenta√ß√£o autom√°tica por fins de simplicidade.\nInstala√ß√£o A instala√ß√£o se divide em alguns pacotes diferentes, mas, para o nosso caso, em que o foco est√° na simplicidade, podemos resumir apenas no pacote opentelemetry-distro. Ele ir√° instalar todas as bibliotecas e ferramentas necess√°rias para fazer a instrumenta√ß√£o autom√°tica.\n1 pip install opentelemetry-distro Ap√≥s fazer a instala√ß√£o, vamos fazer o bootstrap, assim, o opentelemetry identificar√° as bibliotecas que utilizamos e instalar√° tudo que ser√° necess√°rio para instrumenta-las corretamente.\n1 opentelemetry-bootstrap -a install √â poss√≠vel ver quais as bibliotecas extras que ser√£o instaladas atrav√©s do comando opentelemetry-bootstrap -a requirements\nExecutando a Aplica√ß√£o Agora que temos a ferramenta instalada, o comando para iniciar a aplica√ß√£o √© alterado para que o opentelemetry consiga carregar dinamicamente algumas coisas e j√° entregar alguns traces autom√°ticamente, ficando:\n1 2 3 4 opentelemetry-instrument \\ --traces_exporter console \\ --service_name otl-example \\ uvicorn app:app --port 8080 Os par√¢metros tamb√©m podem ser configurados atrav√©s de vari√°veis de ambiente, o que torna mais simples o comando, ficando:\n1 2 3 export OTEL_TRACES_EXPORTER=console export OTEL_SERVICE_NAME=otl-example opentelemetry-instrument uvicorn app:app --port 8080 A instrumenta√ß√£o autom√°tica √© desabilitada sempre que usamos o --reload no uvicorn.\nComo o foco do post √© no APM, apenas as configura√ß√µes para habilita-lo est√£o sendo mostras, mas, se necess√°rio, √© preciso definir outros par√¢metros para habilitar o envio de m√©tricas e logs.\nAp√≥s a execu√ß√£o da aplica√ß√£o usando o comando novo algumas informa√ß√µes novas ser√£o mostradas no console em formato json. Essas informa√ß√µes s√£o alguns traces que s√£o capturados automaticamente pela ferramenta sem precisarmos fazer nenhum tipo de defini√ß√£o.\nAdicionando Traces Manuais Em alguns momentos √© interessante criarmos alguns traces manuais para medir o tempo gasto em alguns pontos da nossa aplica√ß√£o (ex: tempo gasto para obter um dado do banco de dados ou o tempo gasto em alguma requisi√ß√£o externa) ou salvar alguma informa√ß√£o importante do momento.\nPara fazer essa adi√ß√£o, primeiro precisamos obter um tracer (parecido com o que fazemos para obter um logger):\n1 2 from opentelemetry import trace tracer = trace.get_tracer(\u0026#34;diceroller.tracer\u0026#34;) Para criar um span nesse tracer √© necess√°rio criar um contexto novo contendo o c√≥digo que ser√° monitorado, exemplo:\n1 2 with tracer.start_as_current_span(\u0026#34;example\u0026#34;) as example_span: # c√≥digo que obtem algum dado no banco de dados As vezes salvar algumas informa√ß√µes presentes somente naquele momento do c√≥digo pode ser interessante para ajudar a identificar o que estava sendo executado no momento que o trace foi gerado. Essas informa√ß√µes podem ser adicionas ao span de duas formas:\n1 2 3 4 5 6 7 8 # adicionado uma a uma example_span.set_attribute(\u0026#34;roll.value\u0026#34;, result) # adicionando multiplas informa√ß√µes de uma s√≥ vez example_span.set_attributes({ \u0026#34;roll.value\u0026#34;: result, \u0026#34;player\u0026#34;: player, }) C√≥digo Python Final Ap√≥s as modifica√ß√µes descritas anteriormente, nosso c√≥digo ficou da seguinte forma:\napp.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from random import randint from typing import Optional import logging from fastapi import FastAPI from opentelemetry import trace logging.basicConfig(level=logging.INFO) app = FastAPI() logger = logging.getLogger(__name__) tracer = trace.get_tracer(\u0026#34;diceroller.tracer\u0026#34;) def roll(): return randint(1, 6) @app.get(\u0026#34;/rolldice\u0026#34;) async def roll_dice(player: Optional[str] = \u0026#34;Anonymous\u0026#34;): with tracer.start_as_current_span(\u0026#34;example\u0026#34;) as example_span: # Joga o dado e recebe o resultado aleat√≥rio result = roll() example_span.set_attributes({ \u0026#34;roll.value\u0026#34;: result, \u0026#34;player\u0026#34;: player, }) logger.warn(\u0026#34;%s is rolling the dice: %d\u0026#34;, player, result) return {\u0026#34;result\u0026#34;: result} Enviando as informa√ß√µes coletadas para o Servidor de APM Agora que temos nosso c√≥digo escrito utilizando o OpenTelemetry precisamos apenas configurar o backend que ser√° utilizado para salvar essas informa√ß√µes. Para fazer isso vamos definir o endpoint do coletor de dados OpenTelemetry e mudar o exporter de trace do console para o otlp (formato utilizado pelo coletor de dados OpenTelemetry). Podemos fazer isso adicionando alguns par√¢metros ao opentelemetry-instrument ou atr√°ves de vari√°veis de ambiente, como mostrado a seguir:\n1 2 3 4 5 6 7 8 9 10 opentelemetry-instrument \\ --exporter_otlp_endpoint \u0026#39;http://\u0026lt;dominio do coletor\u0026gt;:4317\u0026#39; \\ --traces_exporter otlp \\ --service_name otl-example \\ uvicorn app:app --port 8080 export OTEL_EXPORTER_OTLP_ENDPOINT=\u0026#39;http://\u0026lt;dominio do coletor\u0026gt;:4317\u0026#39; export OTEL_TRACES_EXPORTER=otlp export OTEL_SERVICE_NAME=otl-example opentelemetry-instrument uvicorn app:app --port 8080 Caso o exporter otlp endpoint n√£o seja definido, √© utilizado o valor padr√£o http://localhost:4317/\n√â poss√≠vel enviar as informa√ß√µes para o coletor e o console ao mesmo tempo. Para fazer isso basta definir o exporter como console,otlp.\nColocando tudo para rodar Para mostrar tudo que foi ensinado nesse post funcionando, vamos utilizar o Jaeger como coletor dos dados e observar os dados chegando nele. Para fazer isso vamos executa-lo utilizando o docker:\n1 2 3 4 5 6 7 8 9 10 # executa o jaeger em background docker run -d --rm --name jaeger \\ -p 16686:16686 `# porta da interface web` \\ -p 4317:4317 `# porta do coletor OpenTelemetry` \\ jaegertracing/all-in-one:1.52 # inicia nossa aplica√ß√£o utilizando o endpoint padr√£o export OTEL_TRACES_EXPORTER=console,otlp export OTEL_SERVICE_NAME=otl-example opentelemetry-instrument uvicorn app:app --port 8080 Ap√≥s a aplica√ß√£o iniciar e fazermos algumas requisi√ß√µes, podemos ver os traces chegando no jaeger atrav√©s da interface que pode ser acessada pelo link http://localhost:16686/.\nConclus√£o As vezes a mudan√ßa de ferramenta √© necess√°ria, seja para reduzir custos, adicionar funcionalidades ou para padronizar em uma ferramenta s√≥, mas, nem sempre essa mudan√ßa precisa ser sin√¥nimo de algo ruim. Como vimos nesse post, √© poss√≠vel utilizar de boas ferramentas para das suporte a outras, e assim, criar um ecosistema sustent√°vel em que n√£o precisamos ficar recriando a roda o tempo todo.\n","date":"Dec 29","permalink":"https://blog.lukerops.com/posts/resolvendo-apm-em-python-com-opentelemetry/","tags":["python","opentelemetry","trace","apm"],"title":"Resolvendo APM em Python com OpenTelemetry"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://blog.lukerops.com/posts/","tags":null,"title":"Posts"}]