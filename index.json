[{"categories":["python","datadog","opentelemetry"],"contents":" Introdu√ß√£o A maior vantagem do OpenTelemetry est√° na sua integra√ß√£o com diferentes backends, tornando poss√≠vel o envio das informa√ß√µes para v√°rios locais diferentes sem a necessidade de altera√ß√£o do c√≥digo da aplica√ß√£o, portanto, dando continuidade ao assunto do meu post anterior, nesse post vou abordar o envio dos traces coletados na aplica√ß√£o python para o Datadog.\nIntegra√ß√£o do Datadog com o OpenTelemetry O Datadog, assim como outros provedores de APM j√° se adaptou completamente ao uso do OpenTelemetry como ponto de coleta das informa√ß√µes, portanto, existem algumas formas de configurar essa integra√ß√£o.\nEsteja ciente de que o foco do post √© no envio apenas dos traces, assim, as configura√ß√µes apresentadas funcionar√£o apenas para isso.\nAtualmente existem 3 formas de enviar os dados de trace para o Datadog:\nAtrav√©s do coletor oficial do OpenTelemetry; Atrav√©s do Agente do Datadog; Atrav√©s do cliente ddtrace. OpenTelemetry Collector Junto com o surgimento do OpenTelemetry tamb√©m surgiu o OpenTelemetry Collector (ou Otel Collector). A ideia principal desse coletor √© que ele seja uma forma de receber, processar e exportar os dados completamente agnostica aos provedores contratados, sendo poss√≠vel o envio dos dados para mais de um provedor de forma simult√¢nea.\nSegundo a documenta√ß√£o oficial, √© poss√≠vel utiliza o coletor de tr√™s formas:\nlocal: cada aplica√ß√£o ter√° uma inst√¢ncia do coletor localmente; centralizado: existir√° apenas um inst√¢ncia central do coletor que todas as aplica√ß√µes utilizar√£o; combinado: nesse formato cada aplica√ß√£o pode, ou n√£o, ter uma inst√¢ncia do coletor, mas existir√° outras int√¢ncias, ou seja, um coletor enviar√° os dados para outros coletores, fazendo uma esp√©cie de roteamento dos dados coletados. local Essa forma de utiliza√ß√£o possui a vantagem de ser menos propenso a falhas, j√° que se um coletor apresentar problemas, apenas uma aplica√ß√£o ser√° impactada, por√©m, apresenta uma maior complexidade de gerencia de tokens de acesso, j√° que cada aplica√ß√£o necessitar√° de um token para enviar os dados.\ncentralizado Essa forma de utiliza√ß√£o √© contr√°ria a anterior. Possui uma configura√ß√£o simplificada, por√©m, centraliza todos os dados em uma inst√¢ncia, criando um ponto de falha.\ncombinado Essa forma de utiliza√ß√£o tenta unir as vantagens das anteriores, criando um modelo mais robusto. Como o coletor possui a capacidade de envio dos dados para multiplos locais de forma simult√¢nea, √© poss√≠vel centralizar os dados em mais de um coletor, assim, diminuindo o ponto de falha. Por ainda apresentar os coletores centrais, apenas eles possuem os tokens para envio dos dados, o que torna o gerenciamento dos tokens t√£o simples quanto o modelo centralizado.\nSua desvantagem est√° na complexidade da solu√ß√£o. Como agora sua arquitetura possui mais componentes, isso demanda mais arquivos de configura√ß√£o e mais pontos de aten√ß√£o para seguran√ßa dos dados, tornando toda a coisa mais complexa.\nPor quest√µes de simplicidade, vou abordar apenas o modelo centralizado.\nA configura√ß√£o do coletor √© feita atrav√©s de um arquivo YAML. Para a cria√ß√£o desse arquivo vamos seguir duas documenta√ß√µes: a oficial e a do Datadog. Com isso, chegamos ao seguinte arquivo:\notel-collector-config.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # Nesse se√ß√£o configuramos como nosso coletor ir√° # receber os dados. No nosso caso, configuramos o # otlp para ser nossa entrada de dados atrav√©s # do protocolo grpc na porta padr√£o (4317). receivers: otlp: protocols: grpc: {} # Nessa se√ß√£o configuramos o processamento dos dados # recebidos. No nosso caso, vamos fazer o processamento # em batch usando as configura√ß√µes padr√µes. processors: batch: # Datadog APM tem o limite de envio de 3.2MB. # Configura para que n√£o envie mais do que isso. send_batch_max_size: 1000 send_batch_size: 100 timeout: 10s # Nessa se√ß√£o configuramos como o coletor exportar√° # os dados. No nosso caso, enviaremos para o Datadog. exporters: datadog: api: site: ${env:DD_SITE} key: ${env:DD_API_KEY} # Nessa se√ß√£o configuramos quais componentes do # coletor ser√£o habilitados. No nosso caso, apenas # os traces ser√£o habilitados. service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [datadog] Agora que temos a configura√ß√£o feita podemos iniciar o coletor. Vamos utilizar o docker para fazer isso com o comando:\n1 2 3 4 5 6 7 docker run --rm -d --name otel-collector \\ -e DD_SITE=datadoghq.com \\ -e DD_API_KEY=\u0026#39;\u0026lt;api-key\u0026gt;\u0026#39; \\ -v ./otel-collector-config.yaml:/etc/otel-collector-config.yaml:ro \\ -p 4317:4317 \\ otel/opentelemetry-collector-contrib:latest \\ --config=/etc/otel-collector-config.yaml No caso do Datadog, n√£o podemos esquecer de definir os seguites par√¢metros antes de iniciar nossa aplica√ß√£o:\n1 2 3 export OTEL_TRACES_EXPORTER=otlp export OTEL_SERVICE_NAME=\u0026#39;\u0026lt;service\u0026gt;\u0026#39; export OTEL_RESOURCE_ATTRIBUTES=deployment.environment=\u0026#39;\u0026lt;environment\u0026gt;\u0026#39;,service.version=\u0026#39;\u0026lt;version\u0026gt;\u0026#39; Datadog Agent Atualmente o agente do Datadog possui a funcionalidade de trabalhar tamb√©m como um coletor do OpenTelemetry. Segundo a documenta√ß√£o, para habilitar essa funcionalidade basta definir algumas vari√°veis de ambiente e apontar nossa aplica√ß√£o para utilizar o agente. Como existem duas formas de rodar o agente, serverless e isolado, vou apontar as diferen√ßas na sua configura√ß√£o.\nAssim como no Otel Collector, n√£o podemos esquecer de definir as vari√°veis de ambiente OTEL_TRACES_EXPORTER, OTEL_SERVICE_NAME e OTEL_RESOURCE_ATTRIBUTES.\nServerless Segundo a documenta√ß√£o, esse modo consiste em subir o agente junto a aplica√ß√£o no container. Para configurar o agente serverless a habilitar o OpenTelementry, basta adicionar as seguintes linhas no Dockerfile:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Copia o agente para sua imagem docker. COPY --from=datadog/serverless-init:1 /datadog-init /usr/bin/datadog-init # Define o agente como ponto de entrada da sua imagem. # Obs: o agente que ir√° inicializar sua aplica√ß√£o, assim, basta # definir os comandos de inicializa√ß√£o da aplica√ß√£o como \u0026#34;CMDS\u0026#34;. ENTRYPOINT [\u0026#34;/usr/bin/datadog-init\u0026#34;] # Configura o DD_SITE para onde o agente ir√° enviar os dados. ENV DD_SITE=datadoghq.com # Habilita a coleta de dados de APM. ENV DD_APM_ENABLED=true # Habilita o agente a funcionar como coletor do OpenTelemetry # utilizando o protocolo GRPC. ENV DD_OTLP_CONFIG_RECEIVER_PROTOCOLS_GRPC_ENDPOINT=127.0.0.1:4317 # Habilita a coletas de traces utilizando o OpenTelemetry. ENV DD_OTLP_CONFIG_TRACES_ENABLED=true Por quest√µes de seguran√ßa, nunca adicione o DD_API_KEY na imagem, assim, seu token n√£o ficar√° exposto na imagem docker.\nIsolado O agente do Datadog possui v√°rias formas de ser inicializado. Eu separei esse modo como \u0026ldquo;isolado\u0026rdquo; pelo fato de todas essas formas inicializarem o agente separado da aplica√ß√£o. A configura√ß√£o para esse modo consiste na defini√ß√£o das mesmas vari√°veis de ambiente, apenas alterando o valor de uma delas e definindo uma a mais, ficando:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Configura o token que ser√° utilizado para enviar os dados. DD_API_KEY=\u0026#39;\u0026lt;api-key\u0026gt;\u0026#39; # Configura o DD_SITE para onde o agente ir√° enviar os dados. DD_SITE=datadoghq.com # Habilita a coleta de dados de APM. DD_APM_ENABLED=true # Habilita o agente a receber dados n√£o locais, ou seja, de # outras m√°quinas. # # Obs: utilizar apenas se o agente for coletar dados de aplica√ß√µes # externas a m√°quina/container em que o agente se encontra. DD_APM_NON_LOCAL_TRAFFIC=true # Habilita o agente a funcionar como coletor do OpenTelemetry # utilizando o protocolo GRPC. DD_OTLP_CONFIG_RECEIVER_PROTOCOLS_GRPC_ENDPOINT=0.0.0.0:4317 # Habilita a coletas de traces utilizando o OpenTelemetry. DD_OTLP_CONFIG_TRACES_ENABLED=true Datadog Python APM Client (ddtrace) Quando escrevemos uma aplica√ß√£o em python, uma forma f√°cil de coletar e enviar dados de trace para o Datadog √© atrav√©s do cliente ddtrace. Ele √© respons√°vel por fazer uma instrumenta√ß√£o autom√°tica, mas tamb√©m possibilita o envio de dados customizados pelo c√≥digo, por√©m, estamos fugindo do acoplamento do c√≥digo a apenas um provider de APM.\nPensando na facilidade de se utilizar o ddtrace, foi adicionado uma funcionalidade nova para realizar a configura√ß√£o do OpenTelemetry de forma autom√°tica, assim, utilizando o ddtrace como proxy para que os dados sejam enviados para o agente do Datadog. Para habilitar essa funcionalidade precisamos apenas definir uma vari√°vel de ambiente antes de iniciar o c√≥digo. Usando o comando de inicializa√ß√£o da aplica√ß√£o apresentada no post anterior, fica:\n1 2 3 4 5 6 7 8 9 10 11 12 # Comando de inicializa√ß√£o usando a instrumenta√ß√£o # autom√°tica do OpenTelemetry. export OTEL_SERVICE_NAME=\u0026#39;\u0026lt;service\u0026gt;\u0026#39; export OTEL_RESOURCE_ATTRIBUTES=deployment.environment=\u0026#39;\u0026lt;environment\u0026gt;\u0026#39;,service.version=\u0026#39;\u0026lt;version\u0026gt;\u0026#39; opentelemetry-instrument uvicorn app:app --port 8080 # Comando de inicializa√ß√£o usando o ddtrace. export DD_SERVICE=\u0026#39;\u0026lt;service\u0026gt;\u0026#39; export DD_ENV=\u0026#39;\u0026lt;environment\u0026gt;\u0026#39; export DD_VERSION=\u0026#39;\u0026lt;version\u0026gt;\u0026#39; export DD_TRACE_OTEL_ENABLED=true ddtrace-run uvicorn app:app --port 8080 üö® Aten√ß√£o: o ddtrace coleta apenas dados de trace, portanto, caso queira que m√©tricas e logs tamb√©m sejam coletados, ter√° que mudar para uma das outras solu√ß√µes apresentadas acima.\nConclus√£o Como vimos acima, existem v√°rias formas de integrar seu c√≥digo escrito com OpenTelemetry no Datadog, cada uma com suas vantagens e complexidade diferente. Isso √© importante porque fazendo dessa forma, conseguimos desacoplhar todo o nosso c√≥digo de uma implementa√ß√£o fechada de uma ferramenta, o que torna a mudan√ßa para outra ferramenta, caso necess√°rio, mais simples e r√°pida.\n","date":"Jan 02","permalink":"https://blog.lukerops.com/posts/enviando-dados-do-opentelemetry-para-o-datadog/","tags":["python","datadog","opentelemetry","trace","apm"],"title":"Enviando dados do Opentelemetry para o Datadog"},{"categories":["python","opentelemetry","apm"],"contents":" Introdu√ß√£o Todo desenvolvedor em algum momento de sua carreira j√° passou raiva com mudan√ßa de alguma tecnologia. Sempre que isso acontece, √© necess√°rio fazer uma s√©rie de modifica√ß√µes em um, ou v√°rios, sistemas que tomamos conta e √© exatamente isso que torna todo o processo de mudan√ßa doloroso. Atualmente, a empresa que estou trabalhando, decidiu por mudar a ferramenta de APM que utilizamos para centralizar o trace de todos os sistemas em um lugar s√≥. O problema que essa decis√£o gera √© a mudan√ßa de todos os pontos do c√≥digo que cont√©m a gera√ß√£o de trace utilizando a biblioteca de uma ferramenta para utilizar a biblioteca de outra ferramenta, ou seja, sempre que houver esse tipo de mudan√ßa todo esse trabalho precisar√° ser refeito.\nMas qual √© o problema de verdade? ü§î N√≥s, programadores, somos contratados para resolver problemas, por√©m, sempre que precisamos fazer algum tipo de \u0026ldquo;trabalho bra√ßal\u0026rdquo;, ou seja, ficar realizando alguma tarefa repetitiva, nos sentimos angustiados e desmotivados, e √© exatamente esse tipo de trabalho que √© gerado quando realizamos altera√ß√µes de ferramentas em algum n√≠vel.\nE n√£o tem nada que possamos fazer nessa situa√ß√£o a n√£o ser fazer esse trabalho chato? ü•π Ainda bem que a maioria dos desenvolvedores pensam igual, e com isso, criaram uma ferramenta gen√©rica capaz de centralizar a cria√ß√£o e envio de m√©tricas, traces e logs, assim, podendo ser enviado para v√°rios backends diferentes bastando mudar algumas configura√ß√µes. Essa ferramenta \u0026ldquo;milagrosa\u0026rdquo; que ser√° abordada nesse post √© o OpenTelemetry.\nüö® Observa√ß√£o importante: Como nem tudo s√£o flores, o trabalho chato precisar√° ser feito pelo menos uma vez, mudando da biblioteca atual para o OpenTelemetry.\nExplorando a Solu√ß√£o Aplica√ß√£o de Exemplo Para mostrar como tudo funciona, vamos utilizar uma API simples desenvolvida utilizando o framework web FastAPI:\n1 pip install fastapi uvicorn app.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from random import randint from typing import Optional import logging from fastapi import FastAPI logging.basicConfig(level=logging.INFO) app = FastAPI() logger = logging.getLogger(__name__) def roll(): return randint(1, 6) @app.get(\u0026#34;/rolldice\u0026#34;) async def roll_dice(player: Optional[str] = \u0026#34;Anonymous\u0026#34;): # Joga o dado e recebe o resultado aleat√≥rio result = roll() logger.warn(\u0026#34;%s is rolling the dice: %d\u0026#34;, player, result) return {\u0026#34;result\u0026#34;: result} Para testar a aplica√ß√£o, basta executar:\n1 2 3 4 5 6 7 # inicia a aplica√ß√£o uvicorn app:app --port 8080 # realiza uma requisi√ß√£o usando o player \u0026#34;An√¥nimo\u0026#34; curl -s http://localhost:8080/rolldice # realiza uma requisi√ß√£o usando o player \u0026#34;Lukerops\u0026#34; curl -s http://localhost:8080/rolldice?player=Lukerops Instrumentando o OpenTelemetry Existem duas formas de se instrumentar o OpenTelemetry no python, mas vou focar apenas na instrumenta√ß√£o autom√°tica por fins de simplicidade.\nInstala√ß√£o A instala√ß√£o se divide em alguns pacotes diferentes, mas, para o nosso caso, em que o foco est√° na simplicidade, podemos resumir apenas no pacote opentelemetry-distro. Ele ir√° instalar todas as bibliotecas e ferramentas necess√°rias para fazer a instrumenta√ß√£o autom√°tica.\n1 pip install opentelemetry-distro Ap√≥s fazer a instala√ß√£o, vamos fazer o bootstrap, assim, o opentelemetry identificar√° as bibliotecas que utilizamos e instalar√° tudo que ser√° necess√°rio para instrumenta-las corretamente.\n1 opentelemetry-bootstrap -a install √â poss√≠vel ver quais as bibliotecas extras que ser√£o instaladas atrav√©s do comando opentelemetry-bootstrap -a requirements\nExecutando a Aplica√ß√£o Agora que temos a ferramenta instalada, o comando para iniciar a aplica√ß√£o √© alterado para que o opentelemetry consiga carregar dinamicamente algumas coisas e j√° entregar alguns traces autom√°ticamente, ficando:\n1 2 3 4 opentelemetry-instrument \\ --traces_exporter console \\ --service_name otl-example \\ uvicorn app:app --port 8080 Os par√¢metros tamb√©m podem ser configurados atrav√©s de vari√°veis de ambiente, o que torna mais simples o comando, ficando:\n1 2 3 export OTEL_TRACES_EXPORTER=console export OTEL_SERVICE_NAME=otl-example opentelemetry-instrument uvicorn app:app --port 8080 A instrumenta√ß√£o autom√°tica √© desabilitada sempre que usamos o --reload no uvicorn.\nComo o foco do post √© no APM, apenas as configura√ß√µes para habilita-lo est√£o sendo mostras, mas, se necess√°rio, √© preciso definir outros par√¢metros para habilitar o envio de m√©tricas e logs.\nAp√≥s a execu√ß√£o da aplica√ß√£o usando o comando novo algumas informa√ß√µes novas ser√£o mostradas no console em formato json. Essas informa√ß√µes s√£o alguns traces que s√£o capturados automaticamente pela ferramenta sem precisarmos fazer nenhum tipo de defini√ß√£o.\nAdicionando Traces Manuais Em alguns momentos √© interessante criarmos alguns traces manuais para medir o tempo gasto em alguns pontos da nossa aplica√ß√£o (ex: tempo gasto para obter um dado do banco de dados ou o tempo gasto em alguma requisi√ß√£o externa) ou salvar alguma informa√ß√£o importante do momento.\nPara fazer essa adi√ß√£o, primeiro precisamos obter um tracer (parecido com o que fazemos para obter um logger):\n1 2 from opentelemetry import trace tracer = trace.get_tracer(\u0026#34;diceroller.tracer\u0026#34;) Para criar um span nesse tracer √© necess√°rio criar um contexto novo contendo o c√≥digo que ser√° monitorado, exemplo:\n1 2 with tracer.start_as_current_span(\u0026#34;example\u0026#34;) as example_span: # c√≥digo que obtem algum dado no banco de dados As vezes salvar algumas informa√ß√µes presentes somente naquele momento do c√≥digo pode ser interessante para ajudar a identificar o que estava sendo executado no momento que o trace foi gerado. Essas informa√ß√µes podem ser adicionas ao span de duas formas:\n1 2 3 4 5 6 7 8 # adicionado uma a uma example_span.set_attribute(\u0026#34;roll.value\u0026#34;, result) # adicionando multiplas informa√ß√µes de uma s√≥ vez example_span.set_attributes({ \u0026#34;roll.value\u0026#34;: result, \u0026#34;player\u0026#34;: player, }) C√≥digo Python Final Ap√≥s as modifica√ß√µes descritas anteriormente, nosso c√≥digo ficou da seguinte forma:\napp.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from random import randint from typing import Optional import logging from fastapi import FastAPI from opentelemetry import trace logging.basicConfig(level=logging.INFO) app = FastAPI() logger = logging.getLogger(__name__) tracer = trace.get_tracer(\u0026#34;diceroller.tracer\u0026#34;) def roll(): return randint(1, 6) @app.get(\u0026#34;/rolldice\u0026#34;) async def roll_dice(player: Optional[str] = \u0026#34;Anonymous\u0026#34;): with tracer.start_as_current_span(\u0026#34;example\u0026#34;) as example_span: # Joga o dado e recebe o resultado aleat√≥rio result = roll() example_span.set_attributes({ \u0026#34;roll.value\u0026#34;: result, \u0026#34;player\u0026#34;: player, }) logger.warn(\u0026#34;%s is rolling the dice: %d\u0026#34;, player, result) return {\u0026#34;result\u0026#34;: result} Enviando as informa√ß√µes coletadas para o Servidor de APM Agora que temos nosso c√≥digo escrito utilizando o OpenTelemetry precisamos apenas configurar o backend que ser√° utilizado para salvar essas informa√ß√µes. Para fazer isso vamos definir o endpoint do coletor de dados OpenTelemetry e mudar o exporter de trace do console para o otlp (formato utilizado pelo coletor de dados OpenTelemetry). Podemos fazer isso adicionando alguns par√¢metros ao opentelemetry-instrument ou atr√°ves de vari√°veis de ambiente, como mostrado a seguir:\n1 2 3 4 5 6 7 8 9 10 opentelemetry-instrument \\ --exporter_otlp_endpoint \u0026#39;http://\u0026lt;dominio do coletor\u0026gt;:4317\u0026#39; \\ --traces_exporter otlp \\ --service_name otl-example \\ uvicorn app:app --port 8080 export OTEL_EXPORTER_OTLP_ENDPOINT=\u0026#39;http://\u0026lt;dominio do coletor\u0026gt;:4317\u0026#39; export OTEL_TRACES_EXPORTER=otlp export OTEL_SERVICE_NAME=otl-example opentelemetry-instrument uvicorn app:app --port 8080 Caso o exporter otlp endpoint n√£o seja definido, √© utilizado o valor padr√£o http://localhost:4317/\n√â poss√≠vel enviar as informa√ß√µes para o coletor e o console ao mesmo tempo. Para fazer isso basta definir o exporter como console,otlp.\nColocando tudo para rodar Para mostrar tudo que foi ensinado nesse post funcionando, vamos utilizar o Jaeger como coletor dos dados e observar os dados chegando nele. Para fazer isso vamos executa-lo utilizando o docker:\n1 2 3 4 5 6 7 8 9 10 # executa o jaeger em background docker run -d --rm --name jaeger \\ -p 16686:16686 `# porta da interface web` \\ -p 4317:4317 `# porta do coletor OpenTelemetry` \\ jaegertracing/all-in-one:1.52 # inicia nossa aplica√ß√£o utilizando o endpoint padr√£o export OTEL_TRACES_EXPORTER=console,otlp export OTEL_SERVICE_NAME=otl-example opentelemetry-instrument uvicorn app:app --port 8080 Ap√≥s a aplica√ß√£o iniciar e fazermos algumas requisi√ß√µes, podemos ver os traces chegando no jaeger atrav√©s da interface que pode ser acessada pelo link http://localhost:16686/.\nConclus√£o As vezes a mudan√ßa de ferramenta √© necess√°ria, seja para reduzir custos, adicionar funcionalidades ou para padronizar em uma ferramenta s√≥, mas, nem sempre essa mudan√ßa precisa ser sin√¥nimo de algo ruim. Como vimos nesse post, √© poss√≠vel utilizar de boas ferramentas para das suporte a outras, e assim, criar um ecosistema sustent√°vel em que n√£o precisamos ficar recriando a roda o tempo todo.\n","date":"Dec 29","permalink":"https://blog.lukerops.com/posts/resolvendo-apm-em-python-com-opentelemetry/","tags":["python","opentelemetry","trace","apm"],"title":"Resolvendo APM em Python com OpenTelemetry"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://blog.lukerops.com/posts/","tags":null,"title":"Posts"}]